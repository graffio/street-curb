/* ---------------------------------------------------------------------------------------------------------------------
 * Generators
 *
 * By generating code for a Type Constructor and the related 'toString' and 'from' functions we can create the simplest
 * possible functions for these operations. The generated code must then be eval'd in the proper context
 * (see tagged and taggedSum)
 *
 * Generating Type Checks in the constructors
 * ==========================================
 *
 * To reduce the likelihood of type errors, we generate types-generation checks in the constructors. For example:
 *
 *   generateTypeConstructor('Circle', { centre: 'Coord', radius: 'Number' }) =>
 *
 * Generates this function which checks the number and types of the arguments:
 *
 *   function Circle(centre, radius) {
 *       if (arguments.length !== 2)           throw new TypeError('Expected 2 arguments, found ' + arguments.length)
 *       if (centre['@@typeName'] !== 'Coord') throw new TypeError('Expected centre to be a Coord; found ' + centre)
 *       if (typeof radius !== 'number')       throw new TypeError('Expected radius to be a Number; found ' + radius)
 *
 *       const result = Object.create(prototype)
 *       result.centre = centre
 *       result.radius = radius
 *       return result
 *   }
 *
 * BEWARE: The use of "prototype" in the generated function means there must be a variable named "prototype" in
 * the context where the generated function is eval'd. tagged and taggedSum both define a "prototype."
 *
 * BEWARE: This constructor should be called *without* using the "new" keyword:
 *
 * Correct:     Coord(centre, 4)
 * Incorrect:   new Coord(centre, 4)
 *
 * The type checks are generated by the type of the field, so in this case, two different checks
 * were generated for 'Coord' and 'Number'
 *
 *       ...
 *       if (centre['@@typeName'] !== 'Coord') throw new TypeError('Expected centre to be a Coord; found ' + centre)
 *       if (typeof radius !== 'number')       throw new TypeError('Expected radius to be a Number; found ' + radius)
 *       ...
 *
 * See generateTypeCheck to see the syntax of fieldTypes
 *
 * Primitive Type Handling
 * =======================
 *
 * There is special handling for:
 *
 *     String
 *     Number
 *     Boolean
 *     Object
 *
 * Regex Handling
 * ==============
 *
 * A fieldType can be a regular expression instead of a string, in which case its type is "String"
 * with the additional constraint that its value must match the regular expression:
 *
 *   HasId = tagged('Id', { id: Id ))
 *
 * Produces the extra id.match test in the constructor:
 *
 *   function HasId(id) {
 *       if (arguments.length !== 1) throw new TypeError('Expected 1 arguments, found ' + arguments.length)
 *
 *       if (typeof id !== 'string') throw new TypeError('Expected id to be a String; found ' + id)
 *       if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i))
 *           throw new TypeError('Expected id to match /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i; found ' + id)
 *
 *       const result = Object.create(prototype)
 *       result.id = id
 *       return result
 *   }
 *
 * Array Handling
 * ==============
 *
 * A fieldType can include square brackets to indicate it is an array of a specific type -- even nested:
 *
 * Eg: tagged('NestedArray', { p: '[Number]' } ->
 * Eg: tagged('DoubleNestedArray', { p: '[[Number]]' } ->
 * Eg: tagged('TripleNestedArray', { p: '[[[Number]]]' } ->
 *
 * function toString() { return `NestedArray([${this.p.join(', ')}])` }
 * function toString() { return `DoubleNestedArray([[${this.p[0].join(', ')}]])` }
 * function toString() { return `TripleNestedArray([[[${this.p[0][0].join(', ')}]]])` }
 *
 * Conditional Operator
 * =====================
 *
 * A fieldType can include a '?' suffix indicating that it can be undefined, but if it's present it must
 * have the specified type:
 *
 * TODO: check that type names start with Capital letters
 * ----------------------------------------------------------------------------------------------------------------- */
import TaggedFieldType from './tagged-field-type.js'

// ---------------------------------------------------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------------------------------------------------

/*
 * Generate a Type Constructor function given its name and its fields. See description at top of file
 *
 * @sig generateTypeConstructor = (String, String, { FieldName: fieldType }) -> String
 *  FieldName = String
 *  fieldType = String
 */
const generateTypeConstructor = (typeName, fullTypeName, fields) => {
    // generate "if (x) result.x = x" if x is an optional argument and simply "result.x = x" otherwise
    // this eliminates getting results like: { rotation: undefined }
    const generateAssignment = f => {
        const type = fields[f].toString() // might be a regex
        const isOptional = type.match(/\?/)

        // x != is JavaScript magic for NEITHER null NOR undefined
        return isOptional ? `if (${f} != null) result.${f} = ${f}` : `result.${f} = ${f}`
    }

    const keys = Object.keys(fields)
    const parameterNames = keys.join(', ')

    const constructorName = `${fullTypeName}(${parameterNames})`
    const typeChecks = Object.entries(fields).map(([name, type]) => generateTypeCheck(constructorName, name, type))
    const assignments = keys.map(generateAssignment)

    // if there are optional values, skip the parameter count check
    const hasOptional = Object.values(fields).some(f => (typeof f === 'string' ? f.match(/\?/) : f.optional))
    const countCheck = hasOptional ? '' : `R.validateArgumentLength(constructorName, ${keys.length}, arguments)`

    return `
        function ${typeName}(${parameterNames}) {
            const constructorName = '${constructorName}'
            ${countCheck}
            ${typeChecks.join('\n        ')}

            const result = Object.create(prototype)
            ${assignments.join('\n        ')}
            return result
        }
    `
}

/*
 * Generate guards that validate the type of an actual parameter to a constructor versus its "declared" type
 */
// prettier-ignore
const generateTypeCheck = (constructorName, name, fieldType) => {
    // Handle FieldTypes references specially
    if (typeof fieldType === 'object' && fieldType.__fieldTypesReference)
        return `R.validateRegex(constructorName, ${fieldType.fullReference}, '${name}', false, ${name})`

    /*
     * Checking an array involves 2 separate tests: is the value an array to the proper arrayDepth
     * Does the first completely-nested element match the fieldType?
     *
     * generate a check for the first 'real' element -- no matter how deeply nested it is -- against the
     * fieldType, after first removing the outer brackets
     */
    if (typeof fieldType === 'string' || fieldType instanceof RegExp) fieldType = TaggedFieldType.fromString(fieldType)

    const { baseType, optional, regex, arrayDepth, taggedType } = fieldType
    const containedTag = taggedType ? `"${taggedType}"` : undefined

    if (baseType === 'Any')     return ''
    if (arrayDepth)             return `R.validateArray(constructorName, ${arrayDepth}, '${baseType}', ${containedTag}, '${name}', ${optional}, ${name})`
    if (regex)                  return `R.validateRegex(constructorName, ${regex}, '${name}', ${optional}, ${name})`
    if (baseType === 'String')  return `R.validateString(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Number')  return `R.validateNumber(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Boolean') return `R.validateBoolean(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Object')  return `R.validateObject(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Date')    return `R.validateDate(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Tagged')  return `R.validateTag(constructorName, '${taggedType}', '${name}', ${optional}, ${name})`
}

/*
 * Generate a Type Constructor function for a "Unit Type" like Nil in a LinkedList. Only one instance of Nil
 * will ever be created and all LinkedLists will end by pointing at that one Nil object. There are no fields
 * for a Unit Type so the function is very simple.
 *
 * Note: we generate this function ONLY so that we can give the generated object a name that's visible in
 * debuggers. The "name" of an object (actually the name of its constructor) is read-only and assigned
 * using a complicated set of rules that are hard to follow when generating code.
 *
 * By generating a function with the proper name we guarantee the Unit object will get the proper name. See taggedSum.
 */
const generateUnitConstructor = (protoName, typeName) => `(function ${typeName}() {})`

/*
 * Generate a TypeConstructor.from function given the prototype to use, the name of the Type Constructor and the fields
 *
 * Example:
 *
 * generateFrom('tagProto', 'Square', ['topLeft', 'bottomRight']) =>
 *
 *   (Square => function from(o) {
 *       if (!o.hasOwnProperty('topLeft')) throw new TypeError('Missing field: topLeft')
 *       if (!o.hasOwnProperty('bottomRight')) throw new TypeError('Missing field: bottomRight')
 *
 *       return Square(o.topLeft, o.bottomRight)
 *   })
 */
const generateFrom = (protoName, typeName, fullName, fields) => {
    const fieldNames = Object.keys(fields)
    const params = fieldNames.map(f => `o.${f}`)
    return `o => ${fullName}(${params.join(', ')})`
}

/*
 * Generate a 'toString' function given the name of the Type Constructor and the fields. See tagged/taggedSum
 *
 * Example:
 *
 *   generateToString('Bob', { num: 'Number', s: 'String', o: 'Object', a: '[String]' })
 *
 * Generates
 *
 *  toString: function () {
 *      return `Bob(${_toString(this.num)}, ${_toString(this.s)}, ${_toString(this.o)}, ${_toString(this.a)})`
 *  }
 *
 * Where _toString is a predefined types-generation function
 */
const generateToString = (fieldType, fields) => {
    const generateValueString = name => `\${R._toString(this.${name})}`
    const parameters = `${Object.keys(fields).map(generateValueString).join(', ')}`

    return `
        function() {
            return \`${fieldType}(${parameters})\`
        }
    `
}

const Generator = { generateToString, generateFrom, generateTypeConstructor, generateUnitConstructor }

export default Generator
