// ABOUTME: Generators for type constructor code and related toString/from functions
// ABOUTME: These generate JavaScript code strings that are eval'd to create runtime type constructors

/* ---------------------------------------------------------------------------------------------------------------------
 * Generators
 *
 * By generating code for a Type Constructor and the related 'toString' and 'from' functions we can create the simplest
 * possible functions for these operations. The generated code must then be eval'd in the proper context
 * (see tagged and taggedSum)
 *
 * Generating Type Checks in the constructors
 * ==========================================
 *
 * To reduce the likelihood of type errors, we generate types-generation checks in the constructors. For example:
 *
 *   generateTypeConstructor('Circle', { centre: 'Coord', radius: 'Number' }) =>
 *
 * Generates this function which checks the number and types of the arguments:
 *
 *   function Circle(centre, radius) {
 *       if (arguments.length !== 2)           throw new TypeError('Expected 2 arguments, found ' + arguments.length)
 *       if (centre['@@typeName'] !== 'Coord') throw new TypeError('Expected centre to be a Coord; found ' + centre)
 *       if (typeof radius !== 'number')       throw new TypeError('Expected radius to be a Number; found ' + radius)
 *
 *       const result = Object.create(prototype)
 *       result.centre = centre
 *       result.radius = radius
 *       return result
 *   }
 *
 * BEWARE: The use of "prototype" in the generated function means there must be a variable named "prototype" in
 * the context where the generated function is eval'd. tagged and taggedSum both define a "prototype."
 *
 * BEWARE: This constructor should be called *without* using the "new" keyword:
 *
 * Correct:     Coord(centre, 4)
 * Incorrect:   new Coord(centre, 4)
 *
 * The type checks are generated by the type of the field, so in this case, two different checks
 * were generated for 'Coord' and 'Number'
 *
 *       ...
 *       if (centre['@@typeName'] !== 'Coord') throw new TypeError('Expected centre to be a Coord; found ' + centre)
 *       if (typeof radius !== 'number')       throw new TypeError('Expected radius to be a Number; found ' + radius)
 *       ...
 *
 * See generateTypeCheck to see the syntax of fieldTypes
 *
 * Primitive Type Handling
 * =======================
 *
 * There is special handling for:
 *
 *     String
 *     Number
 *     Boolean
 *     Object
 *
 * Regex Handling
 * ==============
 *
 * A fieldType can be a regular expression instead of a string, in which case its type is "String"
 * with the additional constraint that its value must match the regular expression:
 *
 *   HasId = tagged('Id', { id: Id ))
 *
 * Produces the extra id.match test in the constructor:
 *
 *   function HasId(id) {
 *       if (arguments.length !== 1) throw new TypeError('Expected 1 arguments, found ' + arguments.length)
 *
 *       if (typeof id !== 'string') throw new TypeError('Expected id to be a String; found ' + id)
 *       const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i
 *       if (!id.match(uuidRegex))
 *           throw new TypeError('Expected id to match UUID regex; found ' + id)
 *
 *       const result = Object.create(prototype)
 *       result.id = id
 *       return result
 *   }
 *
 * Array Handling
 * ==============
 *
 * A fieldType can include square brackets to indicate it is an array of a specific type -- even nested:
 *
 * Eg: tagged('NestedArray', { p: '[Number]' } ->
 * Eg: tagged('DoubleNestedArray', { p: '[[Number]]' } ->
 * Eg: tagged('TripleNestedArray', { p: '[[[Number]]]' } ->
 *
 * function toString() { return `NestedArray([${this.p.join(', ')}])` }
 * function toString() { return `DoubleNestedArray([[${this.p[0].join(', ')}]])` }
 * function toString() { return `TripleNestedArray([[[${this.p[0][0].join(', ')}]]])` }
 *
 * Conditional Operator
 * =====================
 *
 * A fieldType can include a '?' suffix indicating that it can be undefined, but if it's present it must
 * have the specified type:
 *
 * TODO: check that type names start with Capital letters
 * ----------------------------------------------------------------------------------------------------------------- */
import FieldTypeIR from './ir/field-type-ir.js'

// ---------------------------------------------------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------------------------------------------------

/**
 * Generate a Type Constructor function given its name and its fields. See description at top of file
 * @sig generateTypeConstructor :: (String, String, { FieldName: fieldType }) -> String
 *     FieldName = String
 *     fieldType = String
 */
const generateTypeConstructor = (typeName, fullTypeName, fields) => {
    /**
     * Generate assignment code for a field - handles optional fields
     * @sig generateAssignment :: String -> String
     */
    const generateAssignment = f => {
        const { optional } = FieldTypeIR.fromAny(fields[f])

        // x != is JavaScript magic for NEITHER null NOR undefined
        return optional ? `if (${f} != null) result.${f} = ${f}` : `result.${f} = ${f}`
    }

    const keys = Object.keys(fields)
    const parameterNames = keys.join(', ')

    const constructorName = `${fullTypeName}(${parameterNames})`
    const typeChecks = Object.entries(fields).map(([name, type]) => generateTypeCheck(constructorName, name, type))
    const assignments = keys.map(generateAssignment)

    // if there are optional values, skip the parameter count check
    const hasOptional = Object.values(fields).some(f => FieldTypeIR.fromAny(f).optional)
    const countCheck = hasOptional ? '' : `R.validateArgumentLength(constructorName, ${keys.length}, arguments)`

    return `
        function ${typeName}(${parameterNames}) {
            const constructorName = '${constructorName}'
            ${countCheck}
            ${typeChecks.join('\n        ')}

            const result = Object.create(prototype)
            ${assignments.join('\n        ')}
            return result
        }
    `
}

/**
 * Generate guards that validate the type of an actual parameter to a constructor versus its "declared" type
 * @sig generateTypeCheck :: (String, String, FieldType) -> String
 */
// prettier-ignore
const generateTypeCheck = (constructorName, name, fieldType) => {
    // Normalize all field types to IR
    const ir = FieldTypeIR.fromAny(fieldType)
    const { arrayDepth, baseType, fieldTypesReference, optional, regex, taggedType } = ir
    const tag = taggedType ? `"${taggedType}"` : undefined

    // Handle FieldTypes references (regex patterns imported from FieldTypes)
    if (fieldTypesReference) return `R.validateRegex(constructorName, ${fieldTypesReference.fullReference}, '${name}', ${optional}, ${name})`

    if (baseType === 'Any')         return ''
    if (arrayDepth)                 return `R.validateArray(constructorName, ${arrayDepth}, '${baseType}', ${tag}, '${name}', ${optional}, ${name})`
    if (baseType === 'LookupTable') return `R.validateLookupTable(constructorName, '${taggedType}', '${name}', ${optional}, ${name})`
    if (regex)                      return `R.validateRegex(constructorName, ${regex}, '${name}', ${optional}, ${name})`
    if (baseType === 'String')      return `R.validateString(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Number')      return `R.validateNumber(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Boolean')     return `R.validateBoolean(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Object')      return `R.validateObject(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Date')        return `R.validateDate(constructorName, '${name}', ${optional}, ${name})`
    if (baseType === 'Tagged')      return `R.validateTag(constructorName, '${taggedType}', '${name}', ${optional}, ${name})`
}

/**
 * Generate a TypeConstructor.from function given the prototype to use, the name of the Type Constructor and the fields
 *
 * Example:
 *
 * generateFrom('tagProto', 'Square', ['topLeft', 'bottomRight']) =>
 *
 *   (Square => function from(o) {
 *       if (!o.hasOwnProperty('topLeft')) throw new TypeError('Missing field: topLeft')
 *       if (!o.hasOwnProperty('bottomRight')) throw new TypeError('Missing field: bottomRight')
 *
 *       return Square(o.topLeft, o.bottomRight)
 *   })
 *
 * @sig generateFrom :: (String, String, String, Fields) -> String
 */
const generateFrom = (protoName, typeName, fullName, fields) => {
    const fieldNames = Object.keys(fields)

    // If 3+ fields, destructure to avoid chain-extraction violations in generated code
    // Use _input to avoid collision with fields named 'o'
    if (fieldNames.length >= 3) {
        const destructure = `const { ${fieldNames.join(', ')} } = _input`
        return `_input => {\n    ${destructure}\n    return ${fullName}(${fieldNames.join(', ')})\n}`
    }

    const params = fieldNames.map(f => `_input.${f}`)
    return `_input => ${fullName}(${params.join(', ')})`
}

/**
 * Generate a 'toString' function given the name of the Type Constructor and the fields. See tagged/taggedSum
 *
 * Example:
 *
 *   generateToString('Bob', { num: 'Number', s: 'String', o: 'Object', a: '[String]' })
 *
 * Generates
 *
 *  toString: function () {
 *      return `Bob(${_toString(this.num)}, ${_toString(this.s)}, ${_toString(this.o)}, ${_toString(this.a)})`
 *  }
 *
 * Where _toString is a predefined types-generation function
 *
 * @sig generateToString :: (String, Fields) -> String
 */
const generateToString = (fieldType, fields) => {
    const generateValueString = name => `\${R._toString(this.${name})}`
    const parameters = `${Object.keys(fields).map(generateValueString).join(', ')}`

    return `
        function() {
            return \`${fieldType}(${parameters})\`
        }
    `
}

const Generator = { generateToString, generateFrom, generateTypeConstructor }

export default Generator
