current_task: "task_4_user_handlers"
status: "in_progress"

tasks:
  - id: "task_1_action_types"
    description: "Define 9 Action tagged type variants for organizations and users"
    status: "completed"
    phase: "Domain Model"
    dependencies: []
    estimated_hours: 3
    implementation: |
        Define 9 Action tagged types in `modules/curb-map/type-definitions/action.type.js`:

        Organization Actions (4):
        - OrganizationCreated: {organizationId, projectId, name}
        - OrganizationUpdated: {organizationId, name?, status?}
        - OrganizationSuspended: {organizationId}
        - OrganizationDeleted: {organizationId}

        User Actions (5):
        - UserCreated: {userId, email, displayName, organizationId, role}
        - UserUpdated: {userId, email?, displayName?}
        - UserDeleted: {userId, organizationId}
        - UserForgotten: {userId, reason}
        - RoleAssigned: {userId, organizationId, role}

        Implementation:
        - Update Action.variants with all 9 types
        - Implement Action.toFirestore() serialization
        - Implement Action.fromFirestore() deserialization
        - Handle all variants in fromFirestore switch
    validation:
      - "All 9 Action variants defined with proper schemas"
      - "toFirestore/fromFirestore handle all variants correctly"
      - "Action.from() creates valid instances for each variant"
    tests:
      - "modules/curb-map/functions/test/action-types.tap.js"

  - id: "task_2_organization_handlers"
    description: "Implement organization event handlers with validation"
    status: "completed"
    phase: "Domain Model"
    dependencies: ["task_1_action_types"]
    estimated_hours: 3
    implementation: |
        Create `modules/curb-map/functions/src/events/organization-handlers.js`:

        Handlers:
        - handleOrganizationCreated(actionRequest)
          * Generate defaultProjectId = FieldTypes.newProjectId()
          * Write to /organizations/{orgId}
          * Create default project at /organizations/{orgId}/projects/{defaultProjectId}
          * Metadata (createdAt/createdBy/updatedAt/updatedBy) from actionRequest.actorId

        - handleOrganizationUpdated(actionRequest)
          * Update /organizations/{orgId}
          * Update name and/or status fields
          * Set updatedAt/updatedBy

        - handleOrganizationSuspended(actionRequest)
          * Update /organizations/{orgId} with status: "suspended"

        - handleOrganizationDeleted(actionRequest)
          * Delete /organizations/{orgId} document

        Validation:
        - Required fields (name)
        - Status enum validation ("active" | "suspended")
    validation:
      - "Organization handlers create/update documents correctly"
      - "OrganizationCreated creates both organization and default project"
      - "defaultProjectId properly links to created project"
      - "Metadata fields set correctly"
      - "Validation rejects invalid data"
    tests:
      - "modules/curb-map/functions/test/organization-handlers.tap.js"

  - id: "task_2_5_http_handler"
    description: "Implement HTTP request handler for action submission"
    status: "completed"
    phase: "HTTP Infrastructure"
    dependencies: ["task_2_organization_handlers"]
    estimated_hours: 4
    implementation: |
        Create HTTP function for action request submission (from F110.7):

        HTTP Function:
        - Import `onRequest` from firebase-functions/v2/https
        - Accept JSON payload: {action, idempotencyKey, correlationId, actorId?}
        - For emulator: Accept actorId in body (bypass auth)
        - Return structured responses: {status, processedAt} or {status, error}

        Validation:
        - Validate request body structure
        - Use ActionRequest.from() for validation
        - Return HTTP 400 for validation errors
        - Return HTTP 409 for duplicate idempotency keys

        Processing:
        - Check idempotency (query completedActions)
        - Dispatch to appropriate handler
        - Write to completedActions
        - Return success response

        Error Handling:
        - Catch validation errors â†’ HTTP 400
        - Catch processing errors â†’ HTTP 500
        - Include error details in response

        Test Updates:
        - Update all tests to use HTTP submission
        - Remove Firestore trigger and actionRequests collection
    validation:
      - "HTTP function accepts POST requests with Action payload"
      - "Validation errors return HTTP 400 with error message"
      - "Successful processing returns HTTP 200 with completion status"
      - "Duplicate idempotency keys return HTTP 409"
      - "All tests pass with HTTP submission"
    tests:
      - "modules/curb-map/test/http-submit-action.firebase.js"
      - "modules/curb-map/test/organization-handlers-http.firebase.js"

  - id: "task_3_transaction_infrastructure"
    description: "Implement transaction-based idempotency infrastructure"
    status: "completed"
    phase: "Infrastructure"
    dependencies: ["task_2_5_http_handler"]
    estimated_hours: 8
    implementation: |
        Implement transaction-based idempotency (from F110.8):

        Facade Transactions:
        - Add optional `tx` parameter to FirestoreAdminFacade constructor
        - All methods: if (tx) { tx.METHOD(...) } else { await docRef.METHOD(...) }
        - Add readOrNull(id) method that returns null instead of throwing
        - Apply to: write, read, readOrNull, create, update, delete, readAll

        Context Updates:
        - Add optional `tx` parameter to createFirestoreContext
        - Pass tx to all FirestoreAdminFacade calls
        - Support both transactional and non-transactional contexts

        Tve transaction Implementation:
        - Use Firestore transactions for atomic duplicate detection
        - Single write as 'completed' with server timestamps
        - HTTP response AFTER transaction completes
        - Return HTTP 409 for duplicates (breaking change)

        Status Field Removal:
        - Remove status field from ActionRequest type definition
        - Remove status validation from Firestore security rules
        - Remove status-based indexes
        - Update documentation

        Test Updates:
        - Write failing tests for transaction behavior
        - Update tests to expect HTTP 409 for duplicates
        - Add tests for serverTimestamp() usage
        - Add tests for atomic duplicate detection
    validation:
      - "Facade accepts optional transaction parameter"
      - "All methods work in both modes"
      - "Transaction-based duplicate detection works atomically"
      - "HTTP 409 for duplicates (breaking change)"
      - "No status field in ActionRequest"
      - "All tests pass with transaction behavior"
    tests:
      - "modules/curb-map/test/firestore-facade-transactions.tap.js"
      - "modules/curb-map/test/organization-handlers-http.firebase.js"
      - "modules/curb-map/test/minimal-http-function.firebase.js"

  - id: "task_3_5_organization_members"
    description: "Add organization members map to data model (type definitions only)"
    status: "completed"
    phase: "Domain Model"
    dependencies: ["task_3_transaction_infrastructure"]
    estimated_hours: 2
    implementation: |
        Update type definitions to support organization member visibility and audit trail with soft delete.

        SCOPE: Type definitions and documentation ONLY. Handler implementation in task_4.

        Type Definitions:
        - Update `organization.type.js`: Add `members` field as Object (map of userId â†’ member data)
          ```
          members: {
            "usr_alice": {
              displayName: "Alice Chen",
              role: "admin",
              addedAt: serverTimestamp(),
              addedBy: "usr_admin",
              removedAt: null,  // null = active, timestamp = removed
              removedBy: null   // null if active, userId if removed
            }
          }
          ```

        - Update `action.type.js`: Rename/add actions for clearer semantics (greenfield, no migration needed)
          * `UserDeleted` â†’ `MemberRemoved` (removes user from org)
          * `RoleAssigned` â†’ `RoleChanged` (changes role)
          * Add `MemberAdded` (adds user to org)

        - Run type generator: `npm run generate-types`

        Documentation Updates:
        - Update `docs/architecture/data-model.md`: Members map structure
        - Update `docs/architecture/security.md`: Member permissions
        - Update `specifications/F110-giant-function/background.md`: Domain model

        Benefits:
        - O(1) member list read (no query needed)
        - Soft delete preserves names for audit trail
        - GDPR compliant: UserForgotten deletes /users/{id}, sets removedAt in all orgs
        - Fits municipal scale (50-500 members, <1MB)

    validation:
      - "Organization type includes members map field"
      - "Action types renamed: MemberRemoved, RoleChanged, MemberAdded"
      - "Documentation updated"
      - "Type generator produces valid types"
    tests:
      - "modules/curb-map/test/organization-type.tap.js"

  - id: "task_4_user_handlers"
    description: "Implement user and member event handlers"
    status: "completed"
    phase: "Domain Model"
    dependencies: ["task_3_5_organization_members"]
    estimated_hours: 4
    implementation: |
        Create `modules/curb-map/functions/src/events/user-handlers.js`:

        Handlers:
        - handleUserCreated(logger, fsContext, actionRequest)
          * Action payload: {userId, email, displayName} - NO organizationId/role
          * Write to /users/{userId}
          * Initialize organizations: {} (empty map)
          * Initialize lastLogin=null, failedAttempts=0
          * Metadata from actionRequest.actorId
          * Note: Use MemberAdded separately to add user to organization

        - handleUserUpdated(logger, fsContext, actionRequest)
          * Update email and/or displayName fields
          * Set updatedAt/updatedBy metadata

        - handleMemberAdded(logger, fsContext, actionRequest)
          * Read org to check if member exists
          * Validate: member with removedAt===null â†’ REJECT (already active)
          * If member exists with removedAt !== null â†’ re-activation: clear removedAt/removedBy, update role/displayName, new addedAt/addedBy
          * If new member â†’ create org.members[userId] with all fields
          * Transaction: Update org.members[userId] AND user.organizations[orgId] atomically using fsContext

        - handleMemberRemoved(logger, fsContext, actionRequest)
          * Validate: member exists and not already removed
          * Transaction: Set org.members[userId].removedAt/removedBy AND delete user.organizations[orgId] atomically
          * User doc stays (may be in other orgs)

        - handleRoleChanged(logger, fsContext, actionRequest)
          * Validate: member exists and not removed
          * Transaction: Update org.members[userId].role AND user.organizations[orgId] atomically using fsContext

        - handleUserForgotten(logger, fsContext, actionRequest) [GDPR]
          * Read user.organizations map
          * For each orgId: set org.members[userId].removedAt/removedBy
          * Delete /users/{userId} completely
          * Note: Eventual consistency (transaction scope per org)

        Pattern Reference:
        - Follow organization-handlers.js pattern for atomic writes
        - Use fsContext.users.write(), fsContext.organizations.update() within same transaction
        - All handlers receive (logger, fsContext, actionRequest) parameters

        Two-Step User Creation Pattern:
        - Step 1: UserCreated {userId, email, displayName}
        - Step 2: MemberAdded {userId, organizationId, role, displayName}
        - Benefits: Users can exist without org membership, supports multi-org users

        Validation:
        - Email format, role enum (admin|member|viewer)
        - Required fields
        - Member state transitions
    validation:
      - "All handlers use atomic transaction pattern for multi-collection writes"
      - "Member validation enforces state transitions"
      - "UserForgotten sets removedAt in all orgs, then deletes /users/{id}"
      - "Soft delete preserves member data for audit"
    tests:
      - "modules/curb-map/test/user-handlers.firebase.js"
      - "modules/curb-map/test/member-handlers.firebase.js"

  - id: "task_5_authentication"
    description: "Implement Firebase Auth token verification"
    status: "partial"  # ~90% complete, PasscodeVerified action deferred to F121
    phase: "Authentication"
    dependencies: ["task_1_action_types"]
    estimated_hours: 8
    actual_hours: 7
    implementation: |
        COMPLETED:
        - âœ… Token verification middleware with Firebase Auth
        - âœ… Specific error messages per auth error code (expired, malformed, invalid, revoked)
        - âœ… User context injection from verified tokens
        - âœ… Auth emulator test infrastructure (email + phone sign-in)
        - âœ… Comprehensive HTTP 401 test coverage
        - âœ… UnauthorizedError logging with original error details
        - âœ… userId claim synchronization in handleUserCreated (safety net)

        DEFERRED TO F121:
        - â¸ï¸ Action.PasscodeRequested (sends SMS with passcode)
        - â¸ï¸ Action.PasscodeVerified (verifies code, sets userId claim, returns token)
        - â¸ï¸ SMS delivery infrastructure
        - â¸ï¸ Auth event logging to F108 (not immediate priority)

        ARCHITECTURAL CHANGES:
        - âŒ Organization-role custom claims REMOVED (see ../../docs/decisions.md#auth-claims-simplification)
        - âœ… Security rules read user doc instead of claims
        - âœ… Only userId claim needed (links token to Firestore user doc)

        IMPORTANT - PRODUCTION BLOCKER:
        - âš ï¸ PasscodeVerified action MUST set userId claim BEFORE UserCreated is submitted
        - âš ï¸ Current: UserCreated sets claim (safety net), but creates deadlock in production
        - âš ï¸ Fix: F121 must implement PasscodeVerified action that:
          1. Verifies passcode via Firebase Auth
          2. Generates userId
          3. Sets claim: await admin.auth().setCustomUserClaims(authUid, { userId })
          4. Returns {userId, authUid, token} to client
          5. Client then submits UserCreated with authUid (token has claim, passes auth)
        - âœ… Tests pass (pre-populate claim, simulating PasscodeVerified)
        - âŒ Production blocked until F121 PasscodeVerified implemented

        userId Claim Sync (see ../../docs/decisions.md#userid-claim-sync):
        - âœ… Add authUid field to UserCreated action
        - âœ… handleUserCreated sets userId claim via admin.auth().setCustomUserClaims()
        - âœ… Update tests to verify claim is set
        - âœ… Note: authUid ONLY in UserCreated (not in member operations)
        - âš ï¸ Claim should already exist (set by PasscodeVerified), UserCreated is safety net
    validation:
      - "âœ… Auth middleware verifies tokens correctly"
      - "âœ… HTTP 401 responses include specific error messages"
      - "âœ… Token userId claim validated"
      - "ðŸš§ userId claim set on UserCreated (implementing)"
      - "â¸ï¸ Passcode authentication (deferred - F121)"
      - "â¸ï¸ Auth events logged to F108 (deferred)"
    tests:
      - "modules/curb-map/test/user-handlers.firebase.js"
      - "modules/curb-map/test/member-handlers.firebase.js"
      - "modules/curb-map/test/minimal-http-function.firebase.js"
    notes: |
      Architecture simplified: removed organization-role custom claims.
      Authorization now reads user doc (single source of truth).
      userId claim bootstrap requires authUid in UserCreated action only.
      See ../../docs/decisions.md#auth-claims-simplification and #userid-claim-sync for rationale.

  - id: "task_6_authorization"
    description: "Implement authorization via Firestore security rules"
    status: "completed"
    phase: "Authorization"
    dependencies: ["task_5_authentication"]
    estimated_hours: 6
    actual_hours: 3
    implementation: |
        COMPLETED:
        - âœ… Firestore security rules for all collections
        - âœ… Organizations: only members can read (isMemberOfOrganization)
        - âœ… Users: can only read own doc (isOwnUserDoc)
        - âœ… Projects: only org members can read
        - âœ… CompletedActions: only org members can read audit logs
        - âœ… All writes restricted to Cloud Functions only
        - âœ… Helper functions for clean rule expressions
        - âœ… Default deny-all for unknown collections

        ARCHITECTURAL CHANGE:
        - âœ… Rules read user doc instead of custom claims
        - âœ… Single source of truth: user.organizations[orgId] field
        - âœ… No stale claims, always fresh authorization

        Security Model:
        - Authentication: Firebase Auth tokens with userId claim
        - Authorization: Firestore security rules read user doc
        - Write Path: HTTP Function â†’ validates â†’ writes to Firestore
        - Read Path: Client â†’ Firestore (rules check user doc)
    validation:
      - "âœ… Security rules enforce org membership correctly"
      - "âœ… Users can only read their own user doc"
      - "âœ… All writes restricted to Cloud Functions"
      - "âœ… Unknown collections default to deny"
      - "âœ… Helper functions make rules maintainable"
    tests:
      - "Tested implicitly via HTTP handler tests (user-handlers, member-handlers, etc)"
      - "Security rules validated by emulator during test execution"
    notes: |
      Architecture simplified: rules read user doc, not custom claims.
      All client writes go through HTTP functions (not direct Firestore writes).
      Dedicated security rules tests deferred (tested via integration tests).

  - id: "task_7_integration_testing"
    description: "End-to-end authentication and authorization testing"
    status: "pending"
    phase: "Integration"
    dependencies: ["task_6_authorization"]
    estimated_hours: 4
    implementation: |
        End-to-end authentication and authorization testing (from F110.5):

        Complete Flow Testing:
        - Test complete flow: auth â†’ write ActionRequest â†’ verify security rules â†’ process event
        - Test data isolation between organizations
        - Test role-based access control via security rules
        - Test unauthorized writes are rejected by Firestore rules

        Integration Tests:
        - Authentication flow with Firebase Auth
        - Authorization via Firestore security rules
        - ActionRequest processing with auth context
        - Data isolation between organizations
        - Role-based access control enforcement

        Security Testing:
        - Test unauthorized access attempts are rejected
        - Test organization-scoped data isolation
        - Test role-based permission enforcement
        - Test hierarchical collection access control
    validation:
      - "End-to-end workflow works correctly"
      - "Data isolation maintained across organizations"
      - "Security rules enforce permissions correctly"
      - "Authentication and authorization integrated"
      - "Unauthorized access properly rejected"
    tests:
      - "modules/curb-map/functions/test/auth-integration.firebase.js"

completed:
  - "task_1_action_types"
  - "task_2_organization_handlers"
  - "task_2_5_http_handler"
  - "task_3_transaction_infrastructure"
  - "task_3_5_organization_members"
  - "task_4_user_handlers"

notes: |
    This specification consolidates the core multi-tenant data model tasks.

    SCOPE: Multi-tenant data model implementation
    - Action type definitions (9 domain events)
    - Event handlers for organization and user management
    - HTTP function infrastructure
    - Transaction-based idempotency
    - Authentication and authorization system

    DEPENDS ON:
    - F108: Event sourcing infrastructure (completed)

    ENABLES:
    - Production-ready multi-tenant system with auth/authorization

    Total: 36 hours (4 completed tasks + 3 pending tasks)
