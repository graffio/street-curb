validation_examples:
  before_after_comparisons:
    
    label_positioning_simplification:
      before:
        description: "Complex collision detection with dual orientation support"
        code_example: |
          const calculateLabelPositions = (isVertical, labelElements) => {
            if (isVertical) {
              return calculateVerticalPositions(labelElements)
            } else {
              return calculateHorizontalPositions(labelElements)
            }
          }
          
          const findFirstAvailableOffset = (rects, offsets, currentRect, i, overlapFn) => {
            const previousRects = rects.slice(0, i)
            const checkCollision = testOffset => 
              hasOffsetCollision(previousRects, offsets, currentRect, overlapFn, testOffset)
            
            return Array.from({ length: i + 1 }, (_, testOffset) => testOffset)
              .find(testOffset => !checkCollision(testOffset)) ?? i
          }
        
      after:
        description: "Simplified collision detection preserving slot-filling algorithm"
        code_example: |
          const calculateLabelPositions = (labelElements) => {
            return calculateVerticalPositions(labelElements)
          }
          
          const findFirstAvailableOffset = (rects, offsets, currentRect, i) => {
            const previousRects = rects.slice(0, i)
            // Simplified but still correct slot-filling logic
            for (let slot = 0; slot <= i; slot++) {
              const hasCollision = previousRects.some((prevRect, j) => 
                prevRect && offsets[j] === slot && hasVerticalOverlap(currentRect, prevRect)
              )
              if (!hasCollision) return slot
            }
            return i
          }
    
    event_handler_simplification:
      before:
        description: "Dual desktop/mobile event systems with complex unified handlers"
        code_example: |
          const buildDragStartHandler = (dragData, setDraggingIndex, i) => e => {
            if (e.target.classList.contains('divider')) {
              e.preventDefault()
              return
            }
            dragData.current = { index: i }
            setDraggingIndex(i)
            e.dataTransfer.effectAllowed = 'move'
          }
          
          const buildDragStartHandlerWithPreview = (dragData, setDraggingIndex, i, containerRef, setDragPreviewPos) => e => {
            if (e.target.classList.contains('divider')) return
            const coords = getBothCoordinates(e)
            const rect = containerRef.current?.getBoundingClientRect()
            if (!rect) return
            const targetRect = e.target.getBoundingClientRect()
            const offsetX = coords.x - targetRect.left
            const offsetY = coords.y - targetRect.top
            dragData.current = { index: i, startY: coords.y, startX: coords.x, isDragging: true, offsetX, offsetY }
            setDraggingIndex(i)
            setDragPreviewPos({ x: coords.x - rect.left - offsetX, y: coords.y - rect.top - offsetY })
          }
        
      after:
        description: "Single touch-based event system"
        code_example: |
          const handleDragStart = (index) => (e) => {
            if (e.target.classList.contains('divider')) return
            setDragState({ isDragging: true, index, startY: e.clientY })
          }
    
    component_decomposition:
      before:
        description: "Monolithic SegmentedCurbEditor with mixed responsibilities"
        code_example: |
          const SegmentedCurbEditor = ({ blockfaceLength = 240 }) => {
            // 320 lines of mixed rendering, state management, and business logic
            const renderTick = (p, i, total) => { /* tick rendering logic */ }
            const renderDragPreview = (draggingIndex, dragPreviewPos, segments, total) => { /* preview logic */ }
            const renderBottomControls = (unknownRemaining, segmentsLength, dispatch) => { /* controls logic */ }
            // ... 300+ more lines
          }
        
      after:
        description: "Decomposed components with single responsibilities"
        code_example: |
          const SegmentedCurbEditor = ({ blockfaceLength = 240 }) => {
            // Main orchestrator - 50 lines
            return (
              <div className="segment-container">
                <SegmentList segments={segments} onDrag={handleDrag} />
                <SegmentRuler tickPoints={tickPoints} total={total} />
                <SegmentControls onAddSegment={handleAddSegment} />
              </div>
            )
          }
          
          const SegmentList = ({ segments, onDrag }) => {
            // Pure rendering - 30 lines
            return segments.map(segment => <SegmentItem key={segment.id} segment={segment} onDrag={onDrag} />)
          }
    
    state_consolidation:
      before:
        description: "Multiple redundant state variables"
        code_example: |
          const [draggingIndex, setDraggingIndex] = useState(null)
          const [editingIndex, setEditingIndex] = useState(null)
          const [dragPreviewPos, setDragPreviewPos] = useState({ x: 0, y: 0 })
          const dragState = useRef({ isDragging: false, startCoord: null, startLength: null, index: null })
        
      after:
        description: "Single consolidated state object"
        code_example: |
          const [dragState, setDragState] = useState({
            isDragging: false,
            index: null,
            previewPos: { x: 0, y: 0 },
            startCoord: null
          })

  validation_criteria:
    
    complexity_reduction:
      - line_count_reduction: "Total lines of code reduced by ~60%"
      - function_count_reduction: "Number of functions reduced by ~50%"
      - state_variable_reduction: "State variables reduced by ~70%"
      - import_reduction: "Number of imports reduced by ~40%"
    
    functionality_preservation:
      - drag_drop_operations: "All drag/drop operations work identically"
      - segment_resizing: "Divider dragging resizes segments correctly"
      - type_changing: "Segment type dropdown works correctly"
      - segment_addition: "Add segment buttons work correctly"
      - visual_consistency: "No visual changes to user interface"
    
    performance_metrics:
      - render_time: "Component render time unchanged or improved"
      - drag_responsiveness: "Drag operations remain responsive"
      - memory_usage: "No memory leaks introduced"
      - bundle_size: "Bundle size not significantly increased"
    
    maintainability_improvement:
      - component_separation: "Clear separation of concerns"
      - single_responsibility: "Each component has single responsibility"
      - testability: "Components are easier to test"
      - readability: "Code is easier to understand"

  test_cases:
    
    label_positioning_test:
      description: "Verify simplified label positioning works correctly"
      setup: "Create SegmentedCurbEditor with multiple segments"
      actions:
        - "Render component with overlapping labels"
        - "Verify labels stack vertically without overlap"
        - "Check label positioning is consistent"
      expected: "Labels positioned correctly using simple vertical stacking"
    
    drag_drop_test:
      description: "Verify simplified drag/drop functionality"
      setup: "Create SegmentedCurbEditor with multiple segments"
      actions:
        - "Drag segment to new position"
        - "Drop segment in new location"
        - "Verify segment order changed correctly"
      expected: "Segment reordering works correctly with simplified handlers"
    
    performance_test:
      description: "Verify performance is maintained"
      setup: "Create SegmentedCurbEditor with many segments"
      actions:
        - "Measure initial render time"
        - "Perform multiple drag operations"
        - "Measure memory usage"
      expected: "Performance metrics unchanged or improved" 